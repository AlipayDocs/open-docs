与页面类似，自定义组件可以有自己的 AXML 模板和 ACSS 样式。

# 示例代码

## .axml 示例代码

AXML 是自定义组件的必选部分：

```html
<!-- /components/index/index.axml -->
<view onTap="onMyClick" id="c-{{$id}}" />
```

## .js 示例代码

```javascript
// /components/index/index.js
Component({
  methods: {
    onMyClick(e) {
      console.log(this.is, this.$id);
    },
  },
});
```

**注意**：与页面不同，用户自定义的事件需要放到 `methods` 对象里面。

# 插槽 slot

自定义组件可以通过声明 props 来与外部调用者互动。这样，组件不仅能接受外部传递的数据，还能调用传入的函数，通知外部发生的变化。然而，这还不够灵活。除了数据的处理与通知，小程序提供的 `slot` 功能使自定义组件的 AXML 结构能够动态整合外部传递的 AXML。这样，调用者可以将 AXML 内容传递给组件，由组件整合出完整的 AXML 结构，提高了组件的灵活性。
## 默认插槽 default slot

示例代码：

```html
<!-- /components/index/index.axml -->
<view>
  <slot>
    <view>default slot & default value</view>
  </slot>
  <view>other</view>
</view>
```

调用者不传递 AXML，示例如下：

```json
// /pages/index/index.json
{
   "usingComponents": {
     "my-component": "/components/index/index"
   }
}
```

```html
<!-- /pages/index/index.axml -->
<my-component />
```

页面输出：

```plain
default slot & default value
other
```

调用者传递 AXML，示例如下：

```html
<!-- /pages/index/index.axml -->
<my-component>
  <view>header</view>
  <view>footer</view>
</my-component>
```

页面输出：

```plain
header
footer
other
```

可以将 slot 理解为插槽，default slot 就是默认插槽。如果调用者在组件标签 `<my-component>` 之间不传递 AXML，则渲染的是默认插槽中的内容。如果调用者在组件标签 `<my-component>` 之间传递了 AXML，则使用这些 AXML 替代默认插槽的内容，从而组装出最终的 AXML 进行渲染。
## 具名插槽 named slot

default slot 只能传递一份 AXML。

复杂的组件需要在不同位置渲染不同的 AXML，即需要传递多个 AXML，此时需要 named slot。使用 named slot 后，外部调用者可以在自定义组件标签的子标签中指定要将哪一部分的 AXML 放入到自定义组件的哪个具名插槽中，而自定义组件标签的子标签中没有指定具名插槽的部分则会放入到默认插槽上。

如果仅传递了具名插槽，则默认插槽不会被覆盖。

示例代码：

```html
<!-- /components/index/index.axml -->
<view>
    <slot>
        <view>default slot & default value</view>
    </slot>
    <slot name="header"></slot>
    <view>body</view>
    <slot name="footer"></slot>
</view>
```

只传递具名插槽，示例如下：

```html
<!-- /pages/index/index.axml -->
<my-component>
    <view slot="header">header</view>
    <view slot="footer">footer</view>
</my-component>
```

页面输出：

```plain
default slot & default value
header
body
footer
```

传递具名插槽与默认插槽，示例如下：

```html
<!-- /pages/index/index.axml -->
<my-component>
    <view>this is to default slot</view>
    <view slot="header">header</view>
    <view slot="footer">footer</view>
</my-component>
```

页面输出：

```plain
this is to default slot
header
body
footer
```
## 作用域插槽 slot-scope

通过使用命名插槽（named slot），自定义组件的 AXML 可以选择使用组件自身的 AXML 或外部调用者（如页面）的 AXML。若使用组件自身的 AXML，可以访问组件内部的数据；通过 props 属性，还可以访问外部调用者的数据。

示例代码：

```javascript
// /components/index/index.js
Component({
  data: {
    x: 1,
  },
  props: {
    y: '',
  },
});
```

```html
<!-- /components/index/index.axml -->
<view>组件数据：{{x}}</view>
<view>页面数据：{{y}}</view>
```

```javascript
// /pages/index/index.js
Page({
  data: { y: 2 },
});
```

```html
<!-- /pages/index/index.axml -->
<my-component y="{{y}}" />
```

页面输出：

```plaintext
组件数据：1
页面数据：2
```

自定义组件通过 slot 使用外部调用者（如页面）的 AXML 时，只能访问外部调用者的数据。

示例代码：

```html
<!-- /components/index/index.axml -->
<view>
  <slot>
    <view>默认插槽和默认值</view>
  </slot>
  <view>body</view>
</view>
```

```javascript
// /pages/index/index.js
Page({
  data: { y: 2 },
});
```

```html
<!-- /pages/index/index.axml -->
<my-component>
  <view>页面数据：{{y}}</view>
</my-component>
```

页面输出：

```html
页面数据：2 body
```

slot scope 使得插槽内容能够访问组件内部的数据。

示例代码：

```javascript
// /components/index/index.js
Component({
  data: {
    x: 1,
  },
});
```

```html
<!-- /components/index/index.axml -->
<view>
  <slot x="{{x}}">
    <view>默认插槽和默认值</view>
  </slot>
  <view>body</view>
</view>
```

```javascript
// /pages/index/index.js
Page({
  data: { y: 2 },
});
```

```html
<!-- /pages/index/index.axml -->
<my-component>
  <view slot-scope="props">
    <view>组件数据：{{props.x}}</view>
    <view>页面数据：{{y}}</view>
  </view>
</my-component>
```

页面输出：

```plaintext
组件数据：1
页面数据：2
body
```

如示例所示，自定义组件通过定义 slot 属性的方式暴露组件内部数据。页面在使用组件时，通过 slot-scope 声明作用域插槽，并用属性值定义临时变量名 props，即可访问到组件内部数据。
# ACSS

和页面一样，自定义组件也可以定义自己的 ACSS 样式。ACSS 会自动被引入使用组件的页面，不需要页面手动引入。可查看 [ACSS 语法](https://opendocs.alipay.com/mini/framework/acss)。

# 自定义组件样式隔离

默认情况下，自定义组件的样式将对外产生影响。从基础库版本 [2.7.2](https://opendocs.alipay.com/mini/framework/lib-upgrade-v2) 开始，可以在自定义组件的 JSON 文件中配置 `styleIsolation`，避免页面的样式影响到外部。例如：

```json
{
  "styleIsolation": "apply-shared"
}
```

该选项支持以下取值：

- `apply-shared` 表示 `app.acss` 样式以及其它（设置了 `shared` 的页面和其它自定义组件）的样式将影响到自定义组件，但自定义组件 ACSS 中指定的样式不会影响外部。
- `shared`（默认）表示 `app.acss` 样式以及其它（设置了 `shared` 的页面和其它自定义组件）的样式将影响到页面，自定义组件 ACSS 中指定的样式也会影响到外部。
# 非虚拟化组件节点
默认情况下，自定义组件是“虚拟的”，即会展示自定义组件内部的第一层节点。但有些时候，开发者希望这个节点是一个“非虚拟化的”。使用时，可以在这个节点设置 `id`、`class`、`style`，就像一个基础组件一样。这时，可以将该自定义组件设置为“非虚拟化”。此特性支持基础库 2.8.0、IDE 3.2.3 及以上版本。

## 配置示例
支持两种配置方式，同时 js 的优先级高于 json。
```javascript
Component({
  mixins: [],
  options: {
    virtualHost: false
  },
  data: {}
});
```
```json
{
  "component": true,
  "virtualHost": false,
  "usingComponents": {}
}
```
```html
<custom-component id="id" class="class" style="color: blue">
    字体是蓝色的
</custom-component>
```

## :host 选择器
当开启 `virtualHost: false` 时，自定义组件可以使用 `:host` 选择器来指定该自定义组件的默认样式。此特性支持基础库 2.8.0、IDE 3.2.3 及以上版本。
```css
:host {
  color: red;
}
```
```html
<custom-component>
    字体是红色的
</custom-component>
```
# 外部样式类

有时，组件希望接受外部传入的样式类。此时可以在 `Component` 中用 `externalClasses` 定义段定义若干个外部样式类。

基础库 [2.8.5](https://opendocs.alipay.com/mini/framework/lib-upgrade-v2) 开始支持外部样式类。

这个特性可以用于实现类似于 `view` 组件的 `hover-class` 属性：页面可以提供一个样式类，赋予 `view` 的 `hover-class`，这个样式类本身写在页面中，而不是在 `view` 组件的实现中。
## 开启外部样式类

由于开发者在开发跨平台小程序时可能已经设置了 `externalClasses` 字段，但之前该设置实际上是无效的（在其他平台会生效）。

为了避免产生非预期行为，因此，需要开发者显式开启外部样式类功能。

通过 Component 构造器的 `options` 配置项设置 `externalClasses: true`，可开启该功能。该功能仅在开启了[样式隔离](https://opendocs.alipay.com/mini/framework/component-template#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB)的自定义组件中生效。

### 示例代码

```javascript
/* 组件 custom-component.js */
Component({
  options: {
    // 开启外部样式类功能
    externalClasses: true
  },
  externalClasses: ['my-class']
});
```

```html
<!-- 组件 custom-component.axml -->
<view class="my-class">这段文本的颜色由组件外的 class 决定</view>
```

这样，组件的使用者可以指定这个样式类对应的 class，就像使用普通属性一样。

```html
<!-- 页面的 AXML -->
<custom-component my-class="red-text"></custom-component>
<custom-component my-class="large-text"></custom-component>
<custom-component my-class="red-text large-text"></custom-component>
```

```css
.red-text {
  color: red;
}
.large-text {
  font-size: 1.5em;
}
```
# 使用示例

下面通过一个示例演示 component2 的使用，具体代码可查看 [component2-demo](https://github.com/ant-mini-program/component2-demo)。

```javascript
// /pages/complex/complex.js
Page({
  data: {
    count: 2
  },
  plus() {
    this.setData({
      count: this.data.count + 1
    });
  }
});
```

```html
<!-- /pages/complex/complex.axml -->
<!-- 
页面中使用自定义组件 i1：
1. 将 this.data.count 通过 props 传递给自定义组件。
2. 自定义组件内部可以通过 this.props 获取，并可以在其 axml 内部直接使用 count。
-->
<i1 count="{{count}}">
  <!-- named slot 会渲染这行内容 -->
  <view slot="slot{{item}}" a:for="{{count}}">{{item}}</view>
  <!-- 
  给 named slot 传递渲染的内容，并使用其传递的参数：
  1. 这里会匹配自定义组件中的 <slot name="scope" value="{{o.value}}">。
  2. 使用其传递的参数，即 c = {value: o.value}。
  -->
  <view slot="scope" slot-scope="c">{{c.value}}</view>
  count: {{count}}
  <!-- default slot 会渲染这行内容 -->
</i1>
<button onTap="plus">count+</button>
```

```javascript
// /components/complex/i1.js
Component({
  data: {
    o: {
      value: 'scope-value'
    }
  },
  onInit() {
    // 组件创建时触发
    console.log('i1 onInit', this.props, this.data);
  },
  deriveDataFromProps(nextProps) {
    // 组件更新时触发
    console.log('i1 deriveDataFromProps', nextProps, this.props, this.data);
  },
  didMount() {
    // 组件创建完毕时触发
    console.log('i1 didMount', this.props, this.data);
  },
  didUpdate(prevProps, prevData) {
    // 组件更新完毕时触发
    console.log('i1 didUpdate', prevProps, prevData, this.props, this.data);
  },
  didUnmount() {
    // 组件删除时触发
    console.log('i1 didUnmount');
  },
  methods: {
    change() {
      this.setData({ 'o.value': 'changed-scope-value' });
    }
  }
});
```

```javascript
// /components/complex/f.sjs
export default function addOne(value) {
  return ++value;
}
```

```html
<!-- /components/complex/i1.axml -->
<!-- 
sjs：safe/subset javascript
1. 可以在 axml 中运行的安全 js 脚本。
2. 可使用其实现一些功能函数。
详见：https://opendocs.alipay.com/mini/framework/sjs
-->
<import-sjs name="addOne" from="./f.sjs" />
<!-- 
default slot：默认插槽
会渲染使用者传入的除具名插槽（named slot）以外的内容；
对于本示例：就是页面 axml 中的 count: {{count}}。
详见：https://opendocs.alipay.com/mini/framework/component-template#axml
-->
<slot />
<!-- 
使用 a:for 渲染列表，使用上面 import-sjs 中引入的 addOne 函数。
-->
<view a:for="{{addOne(count)}}">
  <!-- 
  named slot：具名插槽
  1. 通过 name 与使用者传入内容的一一匹配。
  2. 如果匹配不到，会默认渲染 default。
  详见：/mini/framework/component-template#axml
  -->
  <slot name="slot{{item}}">default</slot>
</view>
<view>
  <!-- 
  named slot：具名插槽
  1. 这里同样是一个具名插槽，同时会传递一些参数给使用者。
  2. 对于本示例，会传递 {value: o.value} 给使用者。
  详见：/mini/framework/component-template#axml
  -->
  <slot name="scope" value="{{o.value}}" />
</view>
<button onTap="change">change scope slot value</button>
```

本示例在 page 中使用自定义组件 i1，并使用了小程序框架提供的以下关键技术：

- 自定义组件体系 component2。
- axml 支持使用 slot。
- axml 中使用 sjs。

本示例初始渲染内容如下：

![](https://gw.alipayobjects.com/zos/skylark-tools/public/files/971a55d7c409082c17ed5f1cc2f8cdcd.png#align=left&display=inline&height=370&originHeight=370&originWidth=508&status=done&style=none&width=508) 控制台依次打印：

```plain
i1 onInit
i1 deriveDataFromProps
i1 didMount
```

**说明**：自定义组件创建阶段依次触发：`onInit`、`deriveDataFromProps`、`didMount` 生命周期。

当点击 `count+` 按钮时，页面渲染如下：

![](https://gw.alipayobjects.com/zos/skylark-tools/public/files/6895abb3a0fc11724aa3882f255c9405.png#align=left&display=inline&height=500&originHeight=500&originWidth=510&status=done&style=none&width=510)

控制台依次打印：

```plain
i1 deriveDataFromProps
i1 didUpdate
```

**说明**：

- 自定义组件更新阶段依次触发：`deriveDataFromProps`、`didUpdate` 生命周期。
- 外部 props 变化会触发 `deriveDataFromProps`。

点击 **change scope slot value** 按钮时，页面渲染如下：

![](https://gw.alipayobjects.com/zos/skylark-tools/public/files/dcd1afecdf2f46bf589c358f20f2bda7.png#align=left&display=inline&height=484&originHeight=484&originWidth=510&status=done&style=none&width=510)

控制台依次打印：

```javascript
i1 deriveDataFromProps
i1 didUpdate
```

**说明**：自定义组件 data 变化也会触发 `deriveDataFromProps`。
# 相关文档

- [acss 语法](https://opendocs.alipay.com/mini/framework/acss)
- [component2 Demo](https://github.com/ant-mini-program/component2-demo)
