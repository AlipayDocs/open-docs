与页面类似，自定义组件也可以拥有自己的 AXML 模板和 ACSS 样式文件。
# 示例代码

## .axml 示例代码

AXML 文件是构建自定义组件的关键部分。以下是一个简单的示例，展示了自定义组件的基本 AXML 结构：

```html
<!-- 自定义组件的 AXML 文件 - /components/index/index.axml -->
<view onTap="onMyClick" id="c-{{$id}}"></view>
```

## .js 示例代码

自定义组件的 JavaScript 文件定义了组件的行为。以下示例代码展示了如何在组件中定义方法：

```javascript
// 自定义组件的 JavaScript 文件 - /components/index/index.js
Component({
  methods: {
    onMyClick(e) {
      console.log(this.is, this.$id);
    }
  }
});
```

**注意**：与页面的不同之处在于，自定义组件中的事件需要定义在 `methods` 对象内。

# 插槽 (slot)

在自定义组件的 JS 文件中，通过支持 `props`，组件可以与外部调用者进行数据交互和通知。然而，为了增强组件的灵活性，小程序提供了 `slot` 功能，允许自定义组件的 AXML 结构动态地整合外部调用者提供的 AXML。这使得组件不仅能处理和通知数据，还能灵活地构建其结构。

## 默认插槽 (default slot)

默认插槽允许外部调用者为组件提供默认的 AXML 内容。以下示例展示了如何定义和使用默认插槽：

### 示例代码

自定义组件定义一个默认插槽：

```html
<!-- 自定义组件中的默认插槽定义 - /components/index/index.axml -->
<view>
  <slot>
    <view>default slot & default value</view>
  </slot>
  <view>其它内容</view>
</view>
```

当调用者不传递任何 AXML 时，将使用默认插槽的内容：

```javascript
// 调用者不传递 AXML - /pages/index/index.json
{
   "usingComponents": {
     "my-component": "/components/index/index"
   }
}
```

```html
<!-- 调用者页面 - /pages/index/index.axml -->
<my-component />
```

页面输出如下：

```plain
default slot & default value
other
```

当调用者传递 AXML 时，传递的内容将替代默认插槽的内容：

```html
<!-- 调用者传递 AXML - /pages/index/index.axml -->
<my-component>
  <view>header</view>
  <view>footer</view>
</my-component>
```

页面输出如下：

```plain
header
footer
other
```

在这种情况下，`slot` 可以被视为一个插槽。当调用者在 `<my-component>` 标签内部不传递任何 AXML 时，将使用默认插槽的内容。如果调用者传递 AXML，则使用传递的内容替代默认插槽，从而构建最终的 AXML 结构。

## 具名插槽 (named slot)

除了默认插槽，复杂的自定义组件可能需要在不同位置渲染不同的 AXML，这时就需要使用具名插槽。具名插槽允许外部调用者精确地控制不同内容的放置位置。

### 示例代码

自定义组件定义了一个默认插槽和两个具名插槽：

```html
<!-- 自定义组件定义具名插槽 - /components/index/index.axml -->
<view>
  <slot>
    <view>default slot & default value</view>
  </slot>
  <slot name="header"></slot>
  <view>body</view>
  <slot name="footer"></slot>
</view>
```

当调用者只传递具名插槽内容时，不会影响默认插槽：

```html
<!-- 调用者只传递具名插槽内容 - /pages/index/index.axml -->
<my-component>
  <view slot="header">header</view>
  <view slot="footer">footer</view>
</my-component>
```

页面输出：

```plain
default slot & default value
header
body
footer
```

当调用者同时传递具名插槽和默认插槽内容时：

```html
<!-- 调用者传递具名插槽与默认插槽内容 - /pages/index/index.axml -->
<my-component>
  <view>this is to default slot</view>
  <view slot="header">header</view>
  <view slot="footer">footer</view>
</my-component>
```

页面输出：

```plain
this is to default slot
header
body
footer
```

## 作用域插槽 (slot-scope)

作用域插槽是一种高级特性，允许自定义组件的 AXML 使用外部调用者（例如页面）的 AXML，同时可以访问组件内部的数据。

### 示例代码

自定义组件的 JavaScript 和 AXML：

```javascript
// /components/index/index.js
Component({
  data: {
    x: 1,
  },
});
```

```html
<!-- /components/index/index.axml -->
<view>
  <slot x="{{x}}">
    <view>default slot & default value</view>
  </slot>
  <view>body</view>
</view>
```

外部调用者的 JavaScript 和 AXML：

```javascript
// /pages/index/index.js
Page({
  data: { y: 2 },
});
```

```html
<!-- /pages/index/index.axml -->
<my-component y="{{y}}">
  <view slot-scope="props">
    <view>component data: {{props.x}}</view>
    <view>page data: {{y}}</view>
  </view>
</my-component>
```

页面输出：

```plain
component data: 1
page data: 2
body
```

在这个示例中，通过定义 `slot-scope`，插槽内容可以同时访问到自定义组件内部的数据 `x` 和页面的数据 `y`。

# ACSS 样式

自定义组件可以定义专属的 ACSS 样式，类似于页面的样式处理方式。这些样式文件会自动被包含在使用该组件的页面中，无需额外的手动引入。

## 示例代码

以下是一个自定义组件的 ACSS 样式定义示例：

```css
/* 自定义组件的 ACSS 样式文件 */
.my-custom-component {
  color: blue;
  font-size: 14px;
}
```

在自定义组件中定义样式后，当组件被页面使用时，这些样式将自动应用于组件，而无需页面进行额外的样式引入。

## 更多信息

关于 ACSS 的详细语法和使用规则，可以参考官方文档：
[ACSS 语法](https://opendocs.alipay.com/mini/framework/acss)

此链接提供了关于 ACSS 语法的完整指南，包括样式的定义、应用及其特性说明。

# 自定义组件样式隔离

在自定义组件中，样式隔离是一个重要的概念，用于控制组件样式的作用范围，以避免样式相互影响。从基础库版本 2.7.2 开始，可以在自定义组件的 JSON 配置文件中使用 `styleIsolation` 选项来设置样式隔离的级别。

## 示例配置

以下是一个样式隔离配置的示例：

```json
{
  "styleIsolation": "apply-shared"
}
```

## 配置选项

`styleIsolation` 选项支持以下值：

- `apply-shared`：该选项意味着 app.acss 的样式以及其它设置了 `shared` 的页面和组件的样式会影响到此自定义组件。但是，该组件的样式不会影响到外部环境。
- `shared`（默认）：该选项表示 app.acss 的样式以及其它设置了 `shared` 的页面和组件的样式不仅会影响到此组件，此组件的样式也会影响到外部环境。

更多信息请参考官方文档：
[基础库版本更新](https://opendocs.alipay.com/mini/framework/lib-upgrade-v2)

此链接提供了关于基础库版本更新的详细信息，包括对新功能和改进的说明。

# 非虚拟化组件节点

在默认情况下，自定义组件是“虚拟的”，即只会展示组件内部的第一层节点。然而，有时开发者可能需要将自定义组件的某个节点作为“非虚拟化”的，这样就可以像基础组件一样直接在节点上设置 `id`、`class`、`style` 等属性。此功能支持基础库 2.8.0、IDE 3.2.3 及以上版本。

## 配置非虚拟化节点

非虚拟化节点可以通过两种方式进行配置，其中 JavaScript 配置的优先级高于 JSON 配置。

### JavaScript 配置

在组件的 JavaScript 文件中，可以通过 `options` 属性设置 `virtualHost`：

```javascript
Component({
  mixins: [],
  options: {
    virtualHost: false
  },
  data: {}
});
```

### JSON 配置

在组件的 JSON 配置文件中，也可以进行相应设置：

```json
{
  "component": true,
  "virtualHost": false,
  "usingComponents": {}
}
```

### 使用非虚拟化节点

当组件配置为非虚拟化时，可以直接在自定义组件上设置样式和属性：

```html
<custom-component id="id" class="class" style="color: blue">
  字体是蓝色的
</custom-component>
```

## :host 选择器

启用 `virtualHost: false` 后，可以在组件的 ACSS 样式文件中使用 `:host` 选择器来指定该组件的默认样式：

```css
:host {
  color: red;
}
```

使用 `:host` 选择器设置样式的组件示例：

```html
<custom-component>
  字体是红色的
</custom-component>
```

这使得自定义组件更灵活，可以更好地融入到使用它们的页面中。

# 外部样式类

在某些情况下，开发者可能希望自定义组件能够接受从外部传入的样式类。这可以通过在组件的 `Component` 构造器中使用 `externalClasses` 字段来实现。自基础库版本 2.8.5 起，小程序开始支持外部样式类。

## 实现外部样式类

要启用外部样式类，需要在 `Component` 构造器的 `options` 中显式地开启此功能。这样做可以避免在跨平台开发中可能出现的非预期行为。

### 示例代码

以下是如何在组件中定义并启用外部样式类的示例：

```javascript
/* 自定义组件 - custom-component.js */
Component({
  options: {
    externalClasses: true // 开启外部样式类功能
  },
  externalClasses: ['my-class']
});
```

```html
<!-- 自定义组件的 AXML 文件 - custom-component.axml -->
<view class="my-class">该文本颜色由外部 class 决定</view>
```

这样，使用自定义组件的开发者可以像设置普通属性一样，指定外部样式类：

```html
<!-- 使用自定义组件的页面 AXML -->
<custom-component my-class="red-text" />
<custom-component my-class="large-text" />
<custom-component my-class="red-text large-text" />
```

并在相应的 ACSS 文件中定义这些样式类：

```css
.red-text {
  color: red;
}
.large-text {
  font-size: 1.5em;
}
```

通过这种方式，自定义组件的样式可以更加灵活地由使用者控制，从而提升组件的可重用性和适应性。

# 使用示例

以下是一个实际的示例，展示了如何使用 component2 构建复杂的自定义组件。完整的示例代码可参考 [component2-demo](https://github.com/ant-mini-program/component2-demo)。

## 页面 JavaScript

在页面的 JavaScript 文件中，我们定义了页面的数据和方法：

```javascript
// 页面 JavaScript - /pages/complex/complex.js
Page({
  data: {
    count: 2
  },
  plus() {
    this.setData({
      count: this.data.count + 1
    });
  }
});
```

## 页面 AXML

页面的 AXML 文件中使用了自定义组件，并传递了数据和插槽内容：

```html
<!-- 页面 AXML - /pages/complex/complex.axml -->
<!-- 页面中使用自定义组件 i1： -->
<!-- 1. 将 this.data.count 通过props传递给自定义组件。 -->
<!-- 2. 自定义组件内部可以通过this.props获取，并可以在其axml内部直接使用 count。 -->
<i1 count="{{count}}">
  <!-- named slot 会渲染这行内容 -->
  <view slot="slot{{item}}" a:for="{{count}}">{{item}}</view>
  <!-- 给 named slot 传递渲染的内容，并使用其传递的参数： -->
  <!-- 1. 这里会匹配自定义组件中的 <slot name="scope" value="{{o.value}}">。 -->
  <!-- 2. 使用其传递的参数，即 c = {value: o.value}。 -->
  <view slot="scope" slot-scope="c">{{c.value}}</view>
  count: {{count}}
  <!-- default slot 会渲染这行内容 -->
</i1>
<button onTap="plus">count+</button>
```

## 自定义组件 JavaScript

自定义组件的 JavaScript 文件定义了组件的数据和生命周期方法：

```javascript
// 自定义组件 JavaScript - /components/complex/i1.js
Component({
  data: {
    o: { value: 'scope-value' }
  },
  onInit() {
    // 组件创建时触发
    console.log('i1 onInit', this.props, this.data);
  },
  deriveDataFromProps(nextProps) {
    // 组件创建时触发或更新时触发
    console.log('i1 deriveDataFromProps', nextProps, this.props, this.data);
  },
  didMount() {
    // 组件创建完毕时触发
    console.log('i1 didMount', this.props, this.data);
  },
  didUpdate(prevProps, prevData) {
    // 组件更新完毕时触发
    console.log('i1 didUpdate', prevProps, prevData, this.props, this.data);
  },
  didUnmount() {
    // 组件删除时触发
    console.log('i1 didUnmount');
  },
  methods: {
    change() {
      this.setData({ 'o.value': 'changed-scope-value' });
    }
  }
});
```

## 自定义组件 AXML

自定义组件的 AXML 文件中使用了插槽和 sjs 脚本：

```html
<!-- 自定义组件 AXML - /components/complex/i1.axml -->
<!-- sjs: safe/subset javascript -->
<!-- 1. 可以在 axml 中运行的安全js脚本 -->
<!-- 2. 可使用其实现一些功能函数 -->
<!-- 详见: https://opendocs.alipay.com/mini/framework/sjs -->
<import-sjs name="addOne" from="./f.sjs" />
<!-- default slot: 默认插槽 -->
<!-- 会渲染使用者传入的除具名插槽(named slot)以外的内容； -->
<!-- 对于本示例: 就是页面axml中的 count: {{count}} -->
<!-- 详见: https://opendocs.alipay.com/mini/framework/component-template#axml -->
<slot />
<!-- 使用 a:for 渲染列表 -->
<!-- 使用上面 import-sjs 中引入的 addOne 函数 -->
<view a:for="{{addOne(count)}}">
  <!-- named slot: 具名插槽 -->
  <!-- 1. 通过 name 与使用者传入内容的一一匹配 -->
  <!-- 2. 如果匹配不到，会默认渲染 default -->
  <!-- 详见: /mini/framework/component-template#axml -->
  <slot name="slot{{item}}">default</slot>
</view>
<view>
  <!-- named slot: 具名插槽 -->
  <!-- 1. 这里同样是一个具名插槽，同时会传递一些参数给使用者 -->
  <!-- 2. 对于本示例，会传递 {value: o.value} 给使用者 -->
  <!-- 详见: /mini/framework/component-template#axml -->
  <slot name="scope" value="{{o.value}}" />
</view>
<button onTap="change">change scope slot value</button>
```

这个示例展示了如何在自定义组件中使用默认插槽、具名插槽和作用域插槽，以及如何通过 sjs 脚本增强组件的功能。

# 相关文档链接

为了更深入地理解和应用本文中讨论的概念和技术，以下是一些有用的资源和文档链接：

- **ACSS 语法**：了解更多关于 ACSS（Alipay CSS）的语法和特性，可以访问 [ACSS 语法文档](https://opendocs.alipay.com/mini/framework/acss)。
- **Component2 示例**：为了查看关于 component2 使用的更详细的示例，可以参考 [component2-demo](https://github.com/ant-mini-program/component2-demo)。

这些资源将帮助您更好地理解和实践自定义组件的高级功能和最佳实践。