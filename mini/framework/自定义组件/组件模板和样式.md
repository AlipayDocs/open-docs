自定义组件和页面具有类似的特性，它们都可以具备独立的 AXML 模板和 ACSS 样式。

# 示例代码

## .axml 示例代码

自定义组件的核心部分是 AXML 模板。以下是一个 .axml 文件的示例代码：

```html
<!-- /components/index/index.axml -->
<view onTap="onMyClick" id="c-{{$id}}" />
```

## .js 示例代码

自定义组件的行为定义在 .js 文件中。以下是相应的示例代码：

```javascript
// /components/index/index.js
Component({
  methods: {
    onMyClick(e) {
      console.log(this.is, this.$id);
    },
  },
});
```

**注意**：与页面不同，自定义组件中的用户定义事件需要放入 `methods` 对象中。

# 插槽 slot

自定义组件通过支持 `props` 来与外部调用者交互，接收数据并通知外部调用者组件内部的变化。除了数据处理和通知外，小程序的 `slot` 机制允许自定义组件的 AXML 结构接受外部传入的 AXML，实现更灵活的组件设计。

## 默认插槽 default slot

下面是关于默认插槽的示例代码：

```html
<!-- /components/index/index.axml -->
<view>
  <slot>
    <view>default slot & default value</view>
  </slot>
  <view>other</view>
</view>
```

当调用者不传递任何 AXML 时，组件会渲染默认插槽的内容。例如：

```javascript
// /pages/index/index.json
{
   "usingComponents": {
     "my-component": "/components/index/index"
   }
}
```

```html
<!-- /pages/index/index.axml -->
<my-component />
```

页面将输出以下内容：

```plain
default slot & default value
other
```

如果调用者传递了 AXML，它会替代默认插槽内容。例如：

```html
<!-- /pages/index/index.axml -->
<my-component>
  <view>header</view>
  <view>footer</view>
</my-component>
```

页面将输出以下内容：

```plain
header
footer
other
```

默认插槽（default slot）可以理解为组件的默认内容展示区域，当调用者未提供特定 AXML 时，组件将展示这些默认内容。

## 具名插槽 named slot

为了在组件的不同部位渲染不同的 AXML，可以使用具名插槽（named slot）。具名插槽允许在组件标签内部指定特定的 AXML 片段放入不同的插槽中。未指定具名插槽的 AXML 片段将放入默认插槽。

如果仅传递了具名插槽，则默认插槽的内容不会被覆盖。以下是具名插槽的示例代码：

```html
<!-- /components/index/index.axml -->
<view>
  <slot>
    <view>default slot & default value</view>
  </slot>
  <slot name="header" />
  <view>body</view>
  <slot name="footer" />
</view>
```

只传递具名插槽时的示例：

```html
<!-- /pages/index/index.axml -->
<my-component>
  <view slot="header">header</view>
  <view slot="footer">footer</view>
</my-component>
```

页面将输出以下内容：

```plain
default slot & default value
header
body
footer
```

同时传递具名插槽和默认插槽时的示例：

```html
<!-- /pages/index/index.axml -->
<my-component>
  <view>this is to default slot</view>
  <view slot="header">header</view>
  <view slot="footer">footer</view>
</my-component>
```

页面将输出以下内容：

```plain
this is to default slot
header
body
footer
```

具名插槽提供了在自定义组件的不同位置插入特定内容的能力，增强了组件的灵活性和可重用性。

## 作用域插槽 slot-scope

作用域插槽允许插槽内容访问自定义组件内的数据。在使用 named slot 时，自定义组件的 AXML 可以使用自定义组件的数据，或者通过 props 属性访问外部调用者的数据。

以下是作用域插槽的示例代码：

```javascript
// /components/index/index.js
Component({
  data: {
    x: 1,
  },
  props: {
    y: '',
  },
});
```

```html
<!-- /components/index/index.axml -->
<view>component data: {{x}}</view>
<view>page data: {{y}}</view>
```

```javascript
// /pages/index/index.js
Page({
  data: { y: 2 },
});
```

```html
<!-- /pages/index/index.axml -->
<my-component y="{{y}}" />
```

页面将输出以下内容：

```plain
component data: 1
page data: 2
```

当使用自定义组件的 AXML 时，可以访问组件内部的数据，而使用外部调用者的 AXML 时，只能访问外部调用者的数据。例如：

```html
<!-- /components/index/index.axml -->
<view>
  <slot>
    <view>default slot & default value</view>
  </slot>
  <view>body</view>
</view>
```

```javascript
// /pages/index/index.js
Page({
  data: { y: 2 },
});
```

```html
<!-- /pages/index/index.axml -->
<my-component>
  <view>page data: {{y}}</view>
</my-component>
```

页面将输出以下内容：

```html
page data: 2 body
```

使用 slot scope，插槽内容可以访问到组件内部的数据。下面是 slot scope 的使用示例：

```javascript
// /components/index/index.js
Component({
  data: {
    x: 1,
  },
});
```

```html
<!-- /components/index/index.axml -->
<view>
  <slot x="{{x}}">
    <view>default slot & default value</view>
  </slot>
  <view>body</view>
</view>
```

```javascript
// /pages/index/index.js
Page({
  data: { y: 2 },
});
```

```html
<!-- /pages/index/index.axml -->
<my-component>
  <view slot-scope="props">
    <view>component data: {{props.x}}</view>
    <view>page data: {{y}}</view>
  </view>
</my-component>
```

页面将输出以下内容：

```plain
component data: 1
page data: 2
body
```

在上述示例中，自定义组件通过定义 slot 属性的方式暴露了组件内部数据。页面使用组件时，通过 slot-scope 声明作用域插槽，通过 props 变量即可访问到组件内部的数据。

# ACSS

自定义组件可以定义自己的 ACSS 样式，类似于页面样式。这些样式会自动应用到使用该组件的页面中，无需手动引入。更多关于 ACSS 的语法信息，请参阅 [ACSS 语法文档](https://opendocs.alipay.com/mini/framework/acss)。

# 自定义组件样式隔离

默认情况下，自定义组件的样式对外部环境具有影响。为避免这种情况，从基础库版本 [2.7.2](https://opendocs.alipay.com/mini/framework/lib-upgrade-v2) 起，可以在组件的 JSON 文件中配置 `styleIsolation`，以实现样式隔离。样式隔离有助于确保组件的样式不会影响到外部环境。

以下是样式隔离的配置示例：

```json
{
  "styleIsolation": "apply-shared"
}
```

`styleIsolation` 支持的取值有：

- `apply-shared`：表示 `app.acss` 和其他设置了 `shared` 的页面或组件的样式将影响到自定义组件，但组件自身的 ACSS 不会影响外部。
- `shared`（默认）：表示 `app.acss` 和其他设置了 `shared` 的页面或组件的样式将影响到页面，且组件自身的 ACSS 也会影响外部。

# 非虚拟化组件节点

在默认情况下，自定义组件被视为“虚拟的”，即只显示自定义组件内部的第一层节点。然而，某些情况下，开发者可能希望组件节点是“非虚拟化的”，即能够像基础组件一样在节点上设置 `id`、`class`、`style` 等属性。此时，可以将自定义组件配置为“非虚拟化”。该功能支持基础库 2.8.0、IDE 3.2.3 及以上版本。

## 配置示例

自定义组件可以通过两种方式配置为“非虚拟化”，且需要注意，`js` 文件的配置优先级高于 `json` 文件。

```javascript
// JavaScript 配置
Component({
  options: {
    virtualHost: false,
  },
  data: {},
});
```

```json
// JSON 配置
{
  "component": true,
  "virtualHost": false,
  "usingComponents": {}
}
```

以下是在页面中使用非虚拟化自定义组件的示例：

```html
<custom-component id="id" class="class" style="color: blue">
  字体是蓝色的
</custom-component>
```

## :host 选择器

当启用 `virtualHost: false` 时，可以使用 `:host` 选择器为自定义组件指定默认样式。该选择器仅在启用了非虚拟化节点的情况下生效。

```css
:host {
  color: red;
}
```

以下是使用 `:host` 选择器的示例：

```html
<custom-component>
  字体是红色的
</custom-component>
```

# 外部样式类

在某些情况下，组件可能需要接受从外部传入的样式类。这可以通过在 `Component` 构造器中定义 `externalClasses` 来实现。从基础库 [2.8.5](https://opendocs.alipay.com/mini/framework/lib-upgrade-v2) 起，外部样式类得到支持。此功能有助于实现更灵活的样式自定义，例如，可以用于实现类似于 `view` 组件的 `hover-class` 属性。

## 开启外部样式类

为避免非预期行为，开发者需要显式开启外部样式类功能。这是因为在开发跨平台小程序时，开发者可能已经设置了 `externalClasses` 字段，但在其它平台可能不生效。该功能仅在开启了[样式隔离](https://opendocs.alipay.com/mini/framework/component-template#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB)的自定义组件中生效。

### 示例代码

以下是开启外部样式类功能的示例：

```javascript
/* 组件 custom-component.js */
Component({
  options: {
    // 开启外部样式类功能
    externalClasses: true,
  },
  externalClasses: ['my-class']
});
```

```html
<!-- 组件 custom-component.axml -->
<view class="my-class">这段文本的颜色由组件外的 class 决定</view>
```

组件的使用者可以指定这个样式类对应的 class，就像使用普通属性一样：

```html
<!-- 页面的 AXML -->
<custom-component my-class="red-text" />
<custom-component my-class="large-text" />
<custom-component my-class="red-text large-text" />
```

```css
.red-text {
  color: red;
}
.large-text {
  font-size: 1.5em;
}
```

# 使用示例

以下是通过一个具体示例来演示 `component2` 的使用，您可以在 [component2-demo](https://github.com/ant-mini-program/component2-demo) 查看完整的代码。

```javascript
// /pages/complex/complex.js
// 页面的 JavaScript 代码
Page({
  data: {
    count: 2,
  },
  plus() {
    this.setData({
      count: this.data.count + 1,
    });
  },
});
```

```html
<!-- /pages/complex/complex.axml -->
<!-- 页面中使用自定义组件 i1：
     1. 将 this.data.count 通过 props 传递给自定义组件。
     2. 自定义组件内部可以通过 this.props 获取，并在其 axml 内部直接使用 count。 -->
<i1 count="{{count}}">
  <!-- named slot 会渲染这行内容 -->
  <view slot="slot{{item}}" a:for="{{count}}">{{item}}</view>
  <!-- 给 named slot 传递渲染的内容，并使用其传递的参数：
       1. 这里会匹配自定义组件中的 <slot name="scope" value="{{o.value}}">。
       2. 使用其传递的参数，即 c = {value: o.value}。 -->
  <view slot="scope" slot-scope="c">{{c.value}}</view>
  count: {{count}}
  <!-- default slot 会渲染这行内容 -->
</i1>
<button onTap="plus">count+</button>
```

```javascript
// /components/complex/i1.js
// 自定义组件的 JavaScript 代码
Component({
  data: {
    o: {
      value: 'scope-value',
    },
  },
  onInit() {
    // 组件创建时触发
    console.log('i1 onInit', this.props, this.data);
  },
  deriveDataFromProps(nextProps) {
    // 组件创建或更新时触发
    console.log('i1 deriveDataFromProps', nextProps, this.props, this.data);
  },
  didMount() {
    // 组件创建完毕时触发
    console.log('i1 didMount', this.props, this.data);
  },
  didUpdate(prevProps, prevData) {
    // 组件更新完毕时触发
    console.log('i1 didUpdate', prevProps, prevData, this.props, this.data);
  },
  didUnmount() {
    // 组件删除时触发
    console.log('i1 didUnmount');
  },
  methods: {
    change() {
      this.setData({ 'o.value': 'changed-scope-value' });
    },
  },
});
```

```javascript
// /components/complex/f.sjs
// SJS 脚本
export default function addOne(value) {
  return ++value;
}
```

```html
<!-- /components/complex/i1.axml -->
<!-- sjs: safe/subset javascript
     1. 可以在 axml 中运行的安全js脚本
     2. 可使用其实现一些功能函数
     详见: https://opendocs.alipay.com/mini/framework/sjs -->
<import-sjs name="addOne" from="./f.sjs" />
<!-- default slot: 默认插槽
     会渲染使用者传入的除具名插槽(named slot)以外的内容；
     对于本示例: 就是页面axml中的 count: {{count}}
     详见: https://opendocs.alipay.com/mini/framework/component-template#axml -->
<slot />
<!-- 使用 a:for 渲染列表
     使用上面 import-sjs 中引入的 addOne 函数 -->
<view a:for="{{addOne(count)}}">
  <!-- named slot: 具名插槽
       1. 通过 name 与使用者传入内容的一一匹配
       2. 如果匹配不到，会默认渲染 default
       详见: https://opendocs.alipay.com/mini/framework/component-template#axml -->
  <slot name="slot{{item}}">default</slot>
</view>
<view>
  <!-- named slot: 具名插槽
       1. 这里同样是一个具名插槽，同时会传递一些参数给使用者
       2. 对于本示例，会传递 {value: o.value} 给使用者
       详见: https://opendocs.alipay.com/mini/framework/component-template#axml -->
  <slot name="scope" value="{{o.value}}" />
</view>
<button onTap="change">change scope slot value</button>
```

本示例在页面中使用自定义组件 `i1`，展示了小程序框架提供的关键技术，包括：

- 自定义组件体系 component2。
- AXML 支持灵活使用 slot。
- AXML 中使用 SJS。

本示例初始渲染内容如下：

![](https://gw.alipayobjects.com/zos/skylark-tools/public/files/971a55d7c409082c17ed5f1cc2f8cdcd.png#align=left&display=inline&height=370&margin=%5Bobject%20Object%5D&originHeight=370&originWidth=508&status=done&style=none&width=508)

控制台会依次打印：

```plain
i1 onInit
i1 deriveDataFromProps
i1 didMount
```

**说明**：自定义组件创建阶段依次触发：`onInit`、`deriveDataFromProps`、`didMount` 生命周期。

当点击 `count+` 按钮时，页面渲染如下：

![](https://gw.alipayobjects.com/zos/skylark-tools/public/files/6895abb3a0fc11724aa3882f255c9405.png#align=left&display=inline&height=500&margin=%5Bobject%20Object%5D&originHeight=500&originWidth=510&status=done&style=none&width=510)

控制台依次打印：

```plain
i1 deriveDataFromProps
i1 didUpdate
```

**说明**：

- 自定义组件更新阶段依次触发：`deriveDataFromProps`、`didUpdate` 生命周期。
- 外部 `props` 变化会触发 `deriveDataFromProps`。

点击 **change scope slot value** 按钮时，页面渲染如下：

![](https://gw.alipayobjects.com/zos/skylark-tools/public/files/dcd1afecdf2f46bf589c358f20f2bda7.png#align=left&display=inline&height=484&margin=%5Bobject%20Object%5D&originHeight=484&originWidth=510&status=done&style=none&width=510)

控制台依次打印：

```javascript
i1 deriveDataFromProps
i1 didUpdate
```

**说明**：自定义组件的 `data` 变化也会触发 `deriveDataFromProps`。

# 相关文档

- [acss 语法](https://opendocs.alipay.com/mini/framework/acss)
- [component2 Demo](https://github.com/ant-mini-program/component2-demo)